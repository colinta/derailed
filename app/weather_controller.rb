# Our WeatherController will display a list of recent weather in Denver
class WeatherController < UIViewController
  # in testing, we'll assign a "fake" storage instance to this property
  attr_accessor :storage

  # the `init` method is the Objective-C equivalent of Ruby's `initialize`
  # method.  Because WeatherController is a subclass of an Objective-C class, we
  # will use it's "designated initializer" (google it).  If we were writing a
  # "pure Ruby" class, we could use `def initialize` instead.
  def init
    # the `init` method *must* return self.  This is an implementation detail
    # of Objective-C.  My habit is to use this `super.tap` block so that self
    # is returned.  This style is getting popular in the RubyMotion community.
    super.tap do
      self.title = 'Denver Weather'
      self.storage = WeatherStorage.new
    end
  end

  # this method is called from the Cocoa Touch framework when the view is
  # needed.  We are expected to assign a `UIView` instance to the `self.view`
  # property of our controller
  def loadView
    # the `frame` is a C-struct (a "boxed" c-struct, in RubyMotion terminology)
    # that has an `origin` and `size` property.  `origin` is a `CGPoint` (x, y
    # properties) and `size` is a `CGSize` (with `width`, `height`).  "CG"
    # stands for "CoreGraphics".

    # This value (`UIScreen.mainScreen.bounds`) is a sensible default when
    # you're dealing with a full-screen view controller.  It is possible to
    # write view controllers for a view that is only meant to cover a portion of
    # the screen, but in most cases you will want a full-screen view controller,
    # and so you can use this frame in those cases.  Actually, it is even MORE
    # common to ignore the `loadView` method altogether, and instead to place
    # your subviews in the default `self.view` instance that is created
    # automatically.
    self.view = UITableView.alloc.initWithFrame(UIScreen.mainScreen.bounds)

    # The `UITableView` will ask its `dataSource` for information related to the
    # data that this table view is displaying.  Google `UITableViewDataSource`
    # to see all the methods you can implement.  At a minimum, you must
    # implement `tableView(numberOfRowsInSection:) and
    # tableView(cellForRowAtIndexPath:)`.
    self.view.dataSource = self

    # We want our controller to be the delegate for our table view so that we
    # can respond to UI events that are generated by the table view.  In our
    # case, we want to know when a row was 'selected', so that we can
    # immediately deselect it.
    self.view.delegate = self

    # cell reuse is a memory-management technique that Apple loves to rely on.
    # The table view will only create and use enough cells to fill the screen.
    # After that, it will reuse those cells so that memory does not need to be
    # allocated for more cells.  This means that you will be getting the *same
    # instance* of the cell over and over, so you have to be careful to
    # completely reset its state (touch handlers, view content, etc).
    # In practice, you should use a custom UITableViewCell subclass, and
    # implement the method `prepareForReuse` to reset the cell values.
    self.view.registerClass(UITableViewCell, forCellReuseIdentifier: 'cell')

    # We're going to use a custom UITableViewCell subclass to display our
    # spinner.  I keep this cell in my handy 'toolbox' of iOS classes, I end up
    # using it on just about every project.
    self.view.registerClass(SpinnerCell, forCellReuseIdentifier: SpinnerCell::ID)
  end

  # when the `UINavigationController` is about to display our view, this method
  # will be called to notify us that our view is going to be added to the view
  # hierarchy.  We'll take this opportunity to start loading our weather data
  def viewWillAppear(animated)
    super  # this method is a UIViewController method, so be a good citizen and
           # notify the parent class.

    # tell our storage class we're ready for it to start generating data, and
    # what to do when new data is available
    self.storage.open do
      # we need to notify our table view that the data has changed
      self.view.reloadData
    end
  end

  # the complement to viewWillAppear, this method is called when a view is going
  # to be removed from the view hierarchy.
  def viewWillDisappear(animated)
    super
    # tell storage class to stop listening for new data
    self.storage.close
  end

  def tableView(table_view, numberOfRowsInSection: section)
    if self.storage.loaded?
      # each entry in storage gets a row in our table view
      self.storage.length
    else
      # data isn't ready yet, so display the spinner cell
      1
    end
  end

  def tableView(table_view, cellForRowAtIndexPath: index_path)
    if self.storage.loaded?
      # this method will always return an instance using the class we specified
      # above; it may be a new instance, it may be a reused cell.
      cell = table_view.dequeueReusableCellWithIdentifier('cell')
      # the stock UITableViewCell has a few labels where we can toss data.  We'll
      # use the `textLabel` view (an instance of `UILabel`).  The label has a
      # `text` property that we can assign a string to.

      # we'll construct a 'text' value based on the "timestamp" and "summary"
      # fields of our incoming data.  We use the `NSIndexPath` object to retrieve
      # the index of the row.
      data = self.storage[index_path.row]
      text = ''  # start with a mutable string
      # add a short date and time
      text << Time.at(data['time']).string_with_style(:short, :short)
      # and add the summary, with ": " between the date and summary
      text << ': ' << data['summary']

      cell.textLabel.text = text
    else
      cell = table_view.dequeueReusableCellWithIdentifier(SpinnerCell::ID)
    end

    return cell
  end

  # When the cell is selected, immediately deselect it.  If we add a
  # detail-view, we would push it onto our navigation controller here.
  def tableView(table_view, didSelectRowAtIndexPath: index_path)
    table_view.deselectRowAtIndexPath(index_path, animated: true)
  end

end
